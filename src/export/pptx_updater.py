"""PowerPoint Speaker Notes Integration.

This module provides safe PowerPoint file modification with speaker notes
integration, backup creation, and integrity validation.
"""

import os
import shutil
import tempfile
from typing import Dict, List, Any, Optional, Tuple
from dataclasses import dataclass
from pathlib import Path
import time
from pptx import Presentation
from pptx.slide import Slide
from loguru import logger

from src.script_generation.script_engine import GeneratedScript, ScriptSection
from src.utils.file_handler import FileHandler
from src.utils.logger import log_execution_time, performance_monitor


@dataclass
class UpdateResult:
    """Result of PowerPoint update operation.
    
    Attributes:
        success: Whether update was successful
        updated_file_path: Path to updated file
        backup_file_path: Path to backup file
        slides_updated: Number of slides updated
        errors: List of errors encountered
        warnings: List of warnings
        metadata: Additional metadata
    """
    success: bool
    updated_file_path: str
    backup_file_path: str
    slides_updated: int
    errors: List[str]
    warnings: List[str]
    metadata: Dict[str, Any]


@dataclass
class NotesUpdateConfig:
    """Configuration for notes update operation.
    
    Attributes:
        mode: Update mode ('replace', 'append', 'prepend')
        preserve_existing: Whether to preserve existing notes
        add_timing_info: Whether to add timing information
        add_quality_info: Whether to add quality metrics
        language: Language for notes formatting
        backup_enabled: Whether to create backup
    """
    mode: str = 'append'
    preserve_existing: bool = True
    add_timing_info: bool = True
    add_quality_info: bool = False
    language: str = 'english'
    backup_enabled: bool = True


class PowerPointUpdater:
    """Safe PowerPoint file updater with speaker notes integration."""
    
    def __init__(self):
        """Initialize PowerPoint updater."""
        self.file_handler = FileHandler()
        
        # Notes formatting templates
        self.notes_templates = {
            'english': {
                'separator': '\n\n--- Generated Script ---\n\n',
                'timing': 'Estimated time: {time} minutes',
                'quality': 'Quality score: {score:.2f}',
                'key_points': 'Key points:',
                'generated_by': 'Generated by AWS SA Script Generator',
                'timestamp': 'Generated on: {timestamp}'
            },
            'korean': {
                'separator': '\n\n--- ìƒì„±ëœ ìŠ¤í¬ë¦½íŠ¸ ---\n\n',
                'timing': 'ì˜ˆìƒ ì†Œìš” ì‹œê°„: {time}ë¶„',
                'quality': 'í’ˆì§ˆ ì ìˆ˜: {score:.2f}',
                'key_points': 'í•µì‹¬ í¬ì¸íŠ¸:',
                'generated_by': 'AWS SA ìŠ¤í¬ë¦½íŠ¸ ìƒì„±ê¸°ë¡œ ìƒì„±ë¨',
                'timestamp': 'ìƒì„±ì¼: {timestamp}'
            }
        }
        
        logger.info("Initialized PowerPoint updater with safe file operations")
    
    @log_execution_time
    def update_speaker_notes(
        self,
        pptx_file_path: str,
        generated_script: GeneratedScript,
        config: Optional[NotesUpdateConfig] = None
    ) -> UpdateResult:
        """Update PowerPoint speaker notes with generated script.
        
        Args:
            pptx_file_path: Path to PowerPoint file
            generated_script: Generated script object
            config: Update configuration
            
        Returns:
            UpdateResult with operation details
        """
        if config is None:
            config = NotesUpdateConfig()
        
        performance_monitor.start_operation("update_speaker_notes")
        
        try:
            # Validate input file
            validation_result = self._validate_input_file(pptx_file_path)
            if not validation_result['valid']:
                return UpdateResult(
                    success=False,
                    updated_file_path="",
                    backup_file_path="",
                    slides_updated=0,
                    errors=validation_result['errors'],
                    warnings=[],
                    metadata={}
                )
            
            # Create backup if enabled
            backup_path = ""
            if config.backup_enabled:
                backup_path = self._create_backup(pptx_file_path)
            
            # Load presentation
            presentation = Presentation(pptx_file_path)
            
            # Update slides with script content
            update_results = self._update_slides_with_script(
                presentation, generated_script, config
            )
            
            # Save updated presentation
            temp_output_path = self._save_updated_presentation(
                presentation, pptx_file_path
            )
            
            # Validate updated file
            if self._validate_updated_file(temp_output_path, len(generated_script.sections)):
                # Replace original file
                shutil.move(temp_output_path, pptx_file_path)
                
                result = UpdateResult(
                    success=True,
                    updated_file_path=pptx_file_path,
                    backup_file_path=backup_path,
                    slides_updated=update_results['updated_count'],
                    errors=[],
                    warnings=update_results['warnings'],
                    metadata={
                        'total_slides': len(presentation.slides),
                        'script_sections': len(generated_script.sections),
                        'update_mode': config.mode,
                        'language': config.language
                    }
                )
            else:
                # Restore from backup if validation failed
                if backup_path and os.path.exists(backup_path):
                    shutil.copy2(backup_path, pptx_file_path)
                
                result = UpdateResult(
                    success=False,
                    updated_file_path="",
                    backup_file_path=backup_path,
                    slides_updated=0,
                    errors=["File validation failed after update"],
                    warnings=[],
                    metadata={}
                )
            
            performance_monitor.end_operation("update_speaker_notes", result.success)
            logger.info(f"PowerPoint update completed: success={result.success}, "
                       f"slides_updated={result.slides_updated}")
            return result
            
        except Exception as e:
            performance_monitor.end_operation("update_speaker_notes", False)
            logger.error(f"PowerPoint update failed: {str(e)}")
            
            return UpdateResult(
                success=False,
                updated_file_path="",
                backup_file_path="",
                slides_updated=0,
                errors=[f"Update operation failed: {str(e)}"],
                warnings=[],
                metadata={}
            )
    
    def _validate_input_file(self, file_path: str) -> Dict[str, Any]:
        """Validate input PowerPoint file.
        
        Args:
            file_path: Path to PowerPoint file
            
        Returns:
            Validation result dictionary
        """
        errors = []
        warnings = []
        
        try:
            # Check file existence
            if not os.path.exists(file_path):
                errors.append(f"File does not exist: {file_path}")
                return {'valid': False, 'errors': errors, 'warnings': warnings}
            
            # Check file extension
            if not file_path.lower().endswith('.pptx'):
                errors.append("File must be a PowerPoint (.pptx) file")
            
            # Check file size
            file_size = os.path.getsize(file_path)
            if file_size > 100 * 1024 * 1024:  # 100MB limit
                warnings.append("File size is very large, processing may be slow")
            
            # Check file accessibility
            if not os.access(file_path, os.R_OK | os.W_OK):
                errors.append("File is not readable or writable")
            
            # Try to load presentation
            try:
                presentation = Presentation(file_path)
                if len(presentation.slides) == 0:
                    errors.append("Presentation contains no slides")
                elif len(presentation.slides) > 100:
                    warnings.append("Presentation has many slides, processing may take time")
            except Exception as e:
                errors.append(f"Cannot load PowerPoint file: {str(e)}")
            
            return {
                'valid': len(errors) == 0,
                'errors': errors,
                'warnings': warnings
            }
            
        except Exception as e:
            return {
                'valid': False,
                'errors': [f"File validation error: {str(e)}"],
                'warnings': []
            }
    
    def _create_backup(self, file_path: str) -> str:
        """Create backup of PowerPoint file.
        
        Args:
            file_path: Path to original file
            
        Returns:
            Path to backup file
        """
        try:
            file_path_obj = Path(file_path)
            timestamp = int(time.time())
            backup_name = f"{file_path_obj.stem}_backup_{timestamp}{file_path_obj.suffix}"
            backup_path = file_path_obj.parent / backup_name
            
            shutil.copy2(file_path, backup_path)
            logger.info(f"Created backup: {backup_path}")
            return str(backup_path)
            
        except Exception as e:
            logger.error(f"Failed to create backup: {str(e)}")
            raise
    
    def _update_slides_with_script(
        self,
        presentation: Presentation,
        script: GeneratedScript,
        config: NotesUpdateConfig
    ) -> Dict[str, Any]:
        """Update slides with script content.
        
        Args:
            presentation: PowerPoint presentation object
            script: Generated script
            config: Update configuration
            
        Returns:
            Update results dictionary
        """
        updated_count = 0
        warnings = []
        templates = self.notes_templates.get(config.language, self.notes_templates['english'])
        
        try:
            # Create mapping of script sections to slides
            script_map = {section.slide_number: section for section in script.sections}
            
            for i, slide in enumerate(presentation.slides):
                slide_number = i + 1
                
                if slide_number in script_map:
                    script_section = script_map[slide_number]
                    
                    # Update slide notes
                    success = self._update_slide_notes(
                        slide, script_section, config, templates
                    )
                    
                    if success:
                        updated_count += 1
                    else:
                        warnings.append(f"Failed to update notes for slide {slide_number}")
                else:
                    warnings.append(f"No script content for slide {slide_number}")
            
            return {
                'updated_count': updated_count,
                'warnings': warnings
            }
            
        except Exception as e:
            logger.error(f"Failed to update slides with script: {str(e)}")
            raise
    
    def _update_slide_notes(
        self,
        slide: Slide,
        script_section: ScriptSection,
        config: NotesUpdateConfig,
        templates: Dict[str, str]
    ) -> bool:
        """Update individual slide notes.
        
        Args:
            slide: PowerPoint slide object
            script_section: Script section for this slide
            config: Update configuration
            templates: Language templates
            
        Returns:
            True if update successful
        """
        try:
            # Get existing notes
            existing_notes = ""
            if slide.notes_slide and slide.notes_slide.notes_text_frame:
                existing_notes = slide.notes_slide.notes_text_frame.text.strip()
            
            # Prepare new notes content
            new_content = self._format_script_content(
                script_section, config, templates
            )
            
            # Combine content based on mode
            if config.mode == 'replace':
                final_content = new_content
            elif config.mode == 'append':
                if existing_notes and config.preserve_existing:
                    final_content = existing_notes + templates['separator'] + new_content
                else:
                    final_content = new_content
            elif config.mode == 'prepend':
                if existing_notes and config.preserve_existing:
                    final_content = new_content + templates['separator'] + existing_notes
                else:
                    final_content = new_content
            else:
                final_content = new_content
            
            # Update slide notes
            if not slide.notes_slide:
                # Create notes slide if it doesn't exist
                notes_slide = slide.notes_slide
            
            slide.notes_slide.notes_text_frame.clear()
            slide.notes_slide.notes_text_frame.text = final_content
            
            return True
            
        except Exception as e:
            logger.error(f"Failed to update slide notes: {str(e)}")
            return False
    
    def _format_script_content(
        self,
        script_section: ScriptSection,
        config: NotesUpdateConfig,
        templates: Dict[str, str]
    ) -> str:
        """Format script content for notes.
        
        Args:
            script_section: Script section
            config: Update configuration
            templates: Language templates
            
        Returns:
            Formatted content string
        """
        content_parts = []
        
        # Add main script content
        content_parts.append(script_section.content)
        
        # Add timing information
        if config.add_timing_info:
            timing_info = templates['timing'].format(time=script_section.time_allocation)
            content_parts.append(f"\nâ±ï¸ {timing_info}")
        
        # Add key points
        if script_section.key_points:
            content_parts.append(f"\nðŸ“ {templates['key_points']}")
            for point in script_section.key_points:
                content_parts.append(f"â€¢ {point}")
        
        # Add interaction cues
        if script_section.interaction_cues:
            content_parts.append("\nðŸ’¬ Interaction Opportunities:")
            for cue in script_section.interaction_cues:
                content_parts.append(f"â€¢ {cue}")
        
        # Add speaker notes
        if script_section.speaker_notes:
            content_parts.append(f"\nðŸ“‹ {script_section.speaker_notes}")
        
        # Add generation info
        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")
        content_parts.extend([
            f"\n---",
            f"{templates['generated_by']}",
            templates['timestamp'].format(timestamp=timestamp)
        ])
        
        return "\n".join(content_parts)
    
    def _save_updated_presentation(
        self,
        presentation: Presentation,
        original_path: str
    ) -> str:
        """Save updated presentation to temporary file.
        
        Args:
            presentation: Updated presentation object
            original_path: Original file path
            
        Returns:
            Path to temporary saved file
        """
        try:
            # Create temporary file
            temp_dir = tempfile.mkdtemp(prefix="pptx_update_")
            temp_path = os.path.join(temp_dir, "updated_presentation.pptx")
            
            # Save presentation
            presentation.save(temp_path)
            
            logger.debug(f"Saved updated presentation to: {temp_path}")
            return temp_path
            
        except Exception as e:
            logger.error(f"Failed to save updated presentation: {str(e)}")
            raise
    
    def _validate_updated_file(self, file_path: str, expected_slides: int) -> bool:
        """Validate updated PowerPoint file.
        
        Args:
            file_path: Path to updated file
            expected_slides: Expected number of slides
            
        Returns:
            True if validation passes
        """
        try:
            # Check file exists and is readable
            if not os.path.exists(file_path):
                logger.error("Updated file does not exist")
                return False
            
            # Try to load presentation
            presentation = Presentation(file_path)
            
            # Check slide count
            if len(presentation.slides) != expected_slides:
                logger.error(f"Slide count mismatch: expected {expected_slides}, "
                           f"got {len(presentation.slides)}")
                return False
            
            # Check that notes were added
            notes_count = 0
            for slide in presentation.slides:
                if slide.notes_slide and slide.notes_slide.notes_text_frame:
                    if slide.notes_slide.notes_text_frame.text.strip():
                        notes_count += 1
            
            if notes_count == 0:
                logger.warning("No speaker notes found in updated presentation")
            
            logger.debug(f"File validation passed: {notes_count} slides have notes")
            return True
            
        except Exception as e:
            logger.error(f"File validation failed: {str(e)}")
            return False
    
    def get_presentation_info(self, file_path: str) -> Dict[str, Any]:
        """Get information about PowerPoint presentation.
        
        Args:
            file_path: Path to PowerPoint file
            
        Returns:
            Dictionary with presentation information
        """
        try:
            presentation = Presentation(file_path)
            
            # Count slides with existing notes
            slides_with_notes = 0
            for slide in presentation.slides:
                if slide.notes_slide and slide.notes_slide.notes_text_frame:
                    if slide.notes_slide.notes_text_frame.text.strip():
                        slides_with_notes += 1
            
            info = {
                'file_path': file_path,
                'file_size': os.path.getsize(file_path),
                'total_slides': len(presentation.slides),
                'slides_with_notes': slides_with_notes,
                'slide_masters': len(presentation.slide_masters),
                'slide_layouts': len(presentation.slide_layouts),
                'core_properties': {
                    'title': presentation.core_properties.title or "",
                    'author': presentation.core_properties.author or "",
                    'subject': presentation.core_properties.subject or "",
                    'created': str(presentation.core_properties.created) if presentation.core_properties.created else "",
                    'modified': str(presentation.core_properties.modified) if presentation.core_properties.modified else ""
                }
            }
            
            return info
            
        except Exception as e:
            logger.error(f"Failed to get presentation info: {str(e)}")
            return {'error': str(e)}
    
    def cleanup_backups(self, directory: str, max_age_hours: int = 24):
        """Clean up old backup files.
        
        Args:
            directory: Directory to clean
            max_age_hours: Maximum age for backup files
        """
        try:
            current_time = time.time()
            max_age_seconds = max_age_hours * 3600
            
            backup_pattern = "*_backup_*.pptx"
            directory_path = Path(directory)
            
            cleaned_count = 0
            for backup_file in directory_path.glob(backup_pattern):
                file_age = current_time - backup_file.stat().st_mtime
                if file_age > max_age_seconds:
                    backup_file.unlink()
                    cleaned_count += 1
            
            if cleaned_count > 0:
                logger.info(f"Cleaned up {cleaned_count} old backup files")
                
        except Exception as e:
            logger.error(f"Failed to cleanup backups: {str(e)}")
